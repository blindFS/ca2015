---
layout: post
title: 第四次作业发布，请与4月17日交！
---


## B1

You are trying to appreciate how important the principle of
locality  is  in  justifying  the  use  of  a  cache  memory,  so  you  experiment  with  a
computer having an L1 data cache and a main memory (you exclusively focus on
data accesses). The latencies (in CPU cycles) of the different kinds of accesses
are as follows: cache hit, 1 cycle; cache miss, 105 cycles; main memory access
with cache disabled, 100 cycles.

a. When you run a program with an overall miss rate of 5%, what
will the average memory access time (in CPU cycles) be?

b. Next, you run a program specifically designed to produce completely 
 random data addresses with no locality. Toward that end, you use an
array of size 256 MB (all of it fits in the main memory). Accesses to random
elements of this array are continuously made (using a uniform random number
generator to generate the elements indices). If your data cache size is 64 KB,
what will the average memory access time be?

c. If you compare the result obtained in part (b) with the main memory 
access time when the cache is disabled, what can you conclude about the
role of the principle of locality in justifying the use of cache memory?

d. You observed that a cache hit produces a gain of 99 cycles (1 cycle
vs. 100), but it produces a loss of 5 cycles in the case of a miss (105 cycles vs.
100). In the general case, we can express these two quantities as G (gain) and
L (loss). Using these two quantities (G and L), identify the highest miss rate
after which the cache use would be disadvantageous.


## B4

 We  compare  the  write  bandwidth  requirements  of
write-through versus write-back caches using a concrete example. Let us assume
that we have a 64 KB cache with a line size of 32 bytes. The cache will allocate a
line on a write miss. If configured as a write-back cache, it will write back the
whole dirty line if it needs to be replaced. We will also assume that the cache is
connected to the lower level in the hierarchy through a 64-bit-wide (8-byte-wide)
bus. The number of CPU cycles for a B-bytes write access on this bus is
For example, an 8-byte write would take  cycles, whereas using
the same formula a 12-byte write would take 15 cycles. Answer the following
questions while referring to the C code snippet below:

	…
	#define PORTION 1 
	… 
	Base = 8*i; 
	for (unsigned int j=base; j < base+PORTION; j++) //assume j is stored in a register
		data[j] = j;


a.  For a write-through  cache, how  many CPU  cycles  are  spent on
write transfers to the memory for the all the combined iterations of the j loop?

b. If the cache is configured as a write-back cache, how many CPU
cycles are spent on writing back a cache line?

c.  Change PORTION to 8 and repeat part (a).

d. What is the minimum number of array updates to the same cache
line (before replacing it) that would render the write-back cache superior?

e. Think of a scenario where all the words of the cache line will be
written (not necessarily using the above code) and a write-through cache will
require fewer total CPU cycles than the write-back cache.


## B6

 Converting  miss  rate  (misses  per  reference)  into  misses  per
instruction  relies  upon  two  factors:  references  per  instruction  fetched  and  the
fraction of fetched instructions that actually commits.

a.  The formula for misses per instruction on page B-5 is written first in
terms of three factors: miss rate, memory accesses, and instruction count. Each
of these factors represents actual events. What is different about writing misses
per instruction as miss rate times the factor memory accesses per instruction?

b.  Speculative processors will fetch instructions that do not commit.
The  formula  for  misses  per  instruction  on  page  B-5  refers  to  misses  per
instruction on the execution path, that is, only the instructions that must actu-
ally be executed to carry out the program. Convert the formula for misses per
instruction  on  page  B-5  into  one  that  uses  only  miss  rate,  references  per
instruction  fetched,  and  fraction  of  fetched  instructions  that  commit.  Why
rely upon these factors rather than those in the formula on page B-5?

c. The conversion in part (b) could yield an incorrect value to the
extent  that  the  value  of  the  factor  references  per  instruction  fetched  is  not
equal to the number of references for any particular instruction. Rewrite the
formula of part (b) to correct this deficiency.
